Index: OverworldMap.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class OverworldMap {\r\n  constructor(config) {\r\n    this.overworld = null;\r\n    this.gameObjects = config.gameObjects;\r\n    this.walls = config.walls || {};\r\n    this.cutsceneSpaces = config.cutsceneSpaces || {};\r\n\r\n    this.lowerImage = new Image();\r\n    this.lowerImage.src = config.lowerSrc;\r\n\r\n    this.upperImage = new Image();\r\n    this.upperImage.src = config.upperSrc;\r\n\r\n    this.isCutScenePlaying = false; \r\n  }\r\n\r\n  drawLowerImage(ctx) { //REMEMBER TO ADD CAMERA!\r\n    ctx.drawImage(this.lowerImage, 0,0)\r\n    // replace 0, 0 utils.withGrid(5) - camera.x, utils.withGrid(5) - camera.y\r\n  }\r\n\r\n  drawUpperImage(ctx) { //REMEMBER TO ADD CAMERA\r\n    ctx.drawImage(this.upperImage, 0,0)\r\n  }\r\n  // replace 0, 0 utils.withGrid(5) - camera.x, utils.withGrid(5) - camera.y\r\n\r\n  isSpaceTaken(currentX, currentY, direction) {\r\n    const {x,y} = utils.nextPosition(currentX,currentY,direction);\r\n    return this.walls[`${x},${y}`] || false;\r\n  }\r\n\r\n  mountObjects() {\r\n    Object.keys(this.gameObjects).forEach(key => {\r\n      let object = this.gameObjects[key];\r\n      object.id = key;\r\n      object.mount(this);\r\n    })\r\n  }\r\n\r\n  async startCutScene(events) {\r\n    this.isCutScenePlaying = true;\r\n    for (let i = 0; i < events.length; i++) {\r\n      const eventHandler = new OverworldEvent({\r\n        event: events[i],\r\n        map: this,\r\n      })\r\n      await eventHandler.init();\r\n    }\r\n    this.isCutScenePlaying = false; \r\n  }\r\n\r\n  checkForActionCutScene() {\r\n    const hero = this.gameObjects[\"hero\"];\r\n    const nextCoords = utils.nextPosition(hero.x, hero.y, hero.direction);\r\n    const match = Object.values(this.gameObjects).find(object =>{\r\n      return `${object.x},${object.y}` == `${nextCoords.x},${nextCoords.y}`\r\n    });\r\n    if(!this.isCutScenePlaying && match && match.talking.length) {\r\n      this.startCutScene(match.talking[0].events);\r\n    }\r\n    console.log({match});\r\n  }\r\n\r\n  checkForFootstepCutscene() {\r\n    const hero = this.gameObjects[\"hero\"];\r\n    const match = this.cutsceneSpaces[ `${hero.x},${hero.y}` ];\r\n    if(!this.isCutScenePlaying && match) {\r\n      this.startCutScene(match[0].events);\r\n    }\r\n  }\r\n\r\n  addWall(x,y) {\r\n    this.walls[`${x},${y}`] = true;\r\n  }\r\n\r\n  deleteWall(x,y) {\r\n    this.walls[`${x},${y}`] = false;\r\n  }\r\n\r\n  moveWall(oldX, oldY, direction) {\r\n    this.deleteWall(oldX, oldY);\r\n    const {x,y} = utils.nextPosition(oldX, oldY, direction);\r\n    this.addWall(x,y)\r\n  }\r\n}\r\n\r\nwindow.OverworldMaps = {\r\n  Shop: {\r\n    lowerSrc: \"./backgrounds/shop.png\",\r\n    upperSrc: \"./backgrounds/hall.png\",\r\n    gameObjects: {\r\n      hero: new Person({\r\n          isPlayerControlled: true,\r\n          x: utils.withGrid(2),\r\n          y: utils.withGrid(3),\r\n      }),\r\n      npc1: new Person({\r\n          x: utils.withGrid(2),\r\n          y: utils.withGrid(10),\r\n          src: \"./sprites/customer1.png\",\r\n          behaviorLoop: [\r\n              //{type:\"walk\", direction:\"up\"},\r\n          ],\r\n          talking: [\r\n            {\r\n              events : [\r\n                {type: \"textMessage\", text: \"Hello, can I have a Cheese Pizza.\", faceHero: \"npc1\"},\r\n              ]\r\n            },\r\n          ]\r\n      }),\r\n      npc2: new Person({\r\n        x: utils.withGrid(11),\r\n        y: utils.withGrid(5),\r\n        src: \"./sprites/customer1.png\",\r\n        behaviorLoop:[\r\n\r\n        ],\r\n        talking: [\r\n          {\r\n            events : [\r\n              {type: \"textMessage\", text: \"Hello, can I have a Cheese Pizza.\", faceHero: \"npc2\"},\r\n            ]\r\n          },\r\n        ]\r\n    }),\r\n    },\r\n    walls: {\r\n      //right side of door way\r\n      [utils.asGridCoord(-1,2)] : true,\r\n      //back of door way \r\n      [utils.asGridCoord(0,1)] : true,\r\n      //side counter \r\n      [utils.asGridCoord(5,4)] : true,\r\n      //[utils.asGridCoord(5,3)] : true,\r\n      //front counter\r\n      [utils.asGridCoord(0,4)] : true,\r\n      [utils.asGridCoord(1,4)] : true,\r\n      [utils.asGridCoord(2,4)] : false, //so the player can talk to the npc that walks up to counter \r\n      [utils.asGridCoord(3,4)] : true,\r\n      [utils.asGridCoord(4,4)] : true,\r\n      //back wall\r\n      [utils.asGridCoord(6,2)] : true,\r\n      [utils.asGridCoord(7,2)] : true,\r\n      [utils.asGridCoord(8,2)] : true,\r\n      [utils.asGridCoord(9,2)] : true,\r\n      [utils.asGridCoord(10,2)] : true,\r\n      [utils.asGridCoord(11,2)] : true,\r\n      [utils.asGridCoord(12,2)] : true,\r\n      //right edge\r\n      [utils.asGridCoord(12,3)] : true,\r\n      [utils.asGridCoord(12,4)] : true,\r\n      [utils.asGridCoord(12,5)] : true,\r\n      [utils.asGridCoord(12,6)] : true,\r\n      [utils.asGridCoord(12,7)] : true,\r\n      [utils.asGridCoord(12,8)] : true,\r\n      [utils.asGridCoord(12,9)] : true,\r\n      [utils.asGridCoord(12,10)] : true,\r\n      //bottom left walls\r\n      [utils.asGridCoord(0,11)] : true,\r\n      [utils.asGridCoord(1,11)] : true,\r\n\r\n      //bottom middle wall\r\n      [utils.asGridCoord(3,11)] : true,\r\n      //bottom right wall \r\n      [utils.asGridCoord(5,11)] : true,\r\n      [utils.asGridCoord(6,11)] : true,\r\n      [utils.asGridCoord(7,11)] : true,\r\n      [utils.asGridCoord(8,11)] : true,\r\n      [utils.asGridCoord(9,11)] : true,\r\n      [utils.asGridCoord(10,11)] : true,\r\n      [utils.asGridCoord(11,11)] : true,\r\n      //left wall\r\n      [utils.asGridCoord(-1,3)] : true,\r\n      [utils.asGridCoord(-1,5)] : true, \r\n      [utils.asGridCoord(-1,6)] : true,\r\n      [utils.asGridCoord(-1,7)] : true,\r\n      [utils.asGridCoord(-1,8)] : true,\r\n      [utils.asGridCoord(-1,9)] : true,\r\n      [utils.asGridCoord(-1,10)] : true,\r\n      //wall behind counter \r\n      [utils.asGridCoord(5,2)] : true,\r\n      [utils.asGridCoord(4,2)] : true,\r\n      [utils.asGridCoord(3,2)] : true,\r\n      [utils.asGridCoord(2,2)] : true,\r\n      [utils.asGridCoord(1,2)] : true,\r\n    },\r\n    cutsceneSpaces: {\r\n      [utils.asGridCoord(11,3)] : [\r\n        {\r\n          events: [\r\n            {who: \"npc2\", type:\"walk\", direction: \"up\"},\r\n            {type: \"textMessage\", text:\"GET BACK TO WORK\"},\r\n          ]\r\n        }\r\n      ],\r\n      [utils.asGridCoord(0,2)] : [\r\n        {\r\n          events: [\r\n            {type: \"changeMap\", map: \"Outside\"},\r\n            //{type: \"textMessage\", text:\"Get ready to hunt for your ingredients!\"},\r\n          ]\r\n        }\r\n      ],\r\n    }\r\n  },\r\n  Outside: {\r\n    lowerSrc: \"./backgrounds/grass.png\",\r\n    upperSrc: \"./backgrounds/outHall.png\",\r\n    //player doesn't spawn in with the grass.png as upperSrc \r\n    //upperSrc: \"./backgrounds/grass.png\",\r\n    gameObjects: {\r\n      hero: new Person({\r\n        isPlayerControlled: true,\r\n        x: utils.withGrid(0),\r\n        y: utils.withGrid(3),\r\n        src: \"./sprites/playerGun.png\",\r\n      }),\r\n      cheese: new Person({\r\n          x: utils.withGrid(2),\r\n          y: utils.withGrid(9),\r\n          src: \"./sprites/cheese.png\",\r\n        behaviorLoop: generateRandomBehaviorLoop(20),\r\n      }),\r\n      cheese1: new Person({\r\n        x: utils.withGrid(10),\r\n        y: utils.withGrid(6),\r\n        src: \"./sprites/cheese.png\",\r\n        behaviorLoop: generateRandomBehaviorLoop(20),\r\n      }),\r\n      cheese2: new Person({\r\n        x: utils.withGrid(6),\r\n        y: utils.withGrid(10),\r\n        src: \"./sprites/cheese.png\",\r\n        behaviorLoop: generateRandomBehaviorLoop(20),\r\n      }),\r\n      cheese3: new Person({\r\n        x: utils.withGrid(9),\r\n        y: utils.withGrid(5),\r\n        src: \"./sprites/cheese.png\",\r\n        behaviorLoop: generateRandomBehaviorLoop(20),\r\n      }),\r\n      cheese4: new Person({\r\n        x: utils.withGrid(1),\r\n        y: utils.withGrid(10),\r\n        src: \"./sprites/cheese.png\",\r\n        behaviorLoop: generateRandomBehaviorLoop(20),\r\n      }),\r\n      cheese5: new Person({\r\n        x: utils.withGrid(6),\r\n        y: utils.withGrid(7),\r\n        src: \"./sprites/cheese.png\",\r\n        behaviorLoop: generateRandomBehaviorLoop(20),\r\n      }),\r\n    },\r\n    walls: {\r\n      //north wall\r\n      [utils.asGridCoord(1, -1)]: true,\r\n      [utils.asGridCoord(2, -1)]: true,\r\n      [utils.asGridCoord(3, -1)]: true,\r\n      [utils.asGridCoord(4, -1)]: true,\r\n      [utils.asGridCoord(5, -1)]: true,\r\n      [utils.asGridCoord(6, -1)]: true,\r\n      [utils.asGridCoord(7, -1)]: true,\r\n      [utils.asGridCoord(8, -1)]: true,\r\n      [utils.asGridCoord(9, -1)]: true,\r\n      [utils.asGridCoord(10, -1)]: true,\r\n      [utils.asGridCoord(11, -1)]: true,\r\n      [utils.asGridCoord(12, -1)]: true,\r\n\r\n      //east wall\r\n      [utils.asGridCoord(12, 0)]: true,\r\n      [utils.asGridCoord(12, 1)]: true,\r\n      [utils.asGridCoord(12, 2)]: true,\r\n      [utils.asGridCoord(12, 3)]: true,\r\n      [utils.asGridCoord(12, 4)]: true,\r\n      [utils.asGridCoord(12, 5)]: true,\r\n      [utils.asGridCoord(12, 6)]: true,\r\n      [utils.asGridCoord(12, 7)]: true,\r\n      [utils.asGridCoord(12, 8)]: true,\r\n      [utils.asGridCoord(12, 9)]: true,\r\n      [utils.asGridCoord(12, 10)]: true,\r\n      [utils.asGridCoord(12, 11)]: true,\r\n      [utils.asGridCoord(12, 12)]: true,\r\n\r\n      //south wall\r\n      [utils.asGridCoord(0, 11)]: true,\r\n      [utils.asGridCoord(1, 11)]: true,\r\n      [utils.asGridCoord(2, 11)]: true,\r\n      [utils.asGridCoord(3, 11)]: true,\r\n      [utils.asGridCoord(4, 11)]: true,\r\n      [utils.asGridCoord(5, 11)]: true,\r\n      [utils.asGridCoord(6, 11)]: true,\r\n      [utils.asGridCoord(7, 11)]: true,\r\n      [utils.asGridCoord(8, 11)]: true,\r\n      [utils.asGridCoord(9, 11)]: true,\r\n      [utils.asGridCoord(10, 11)]: true,\r\n      [utils.asGridCoord(11, 11)]: true,\r\n      [utils.asGridCoord(12, 11)]: true,\r\n\r\n      //west wall\r\n      [utils.asGridCoord(-1, 0)]: true,\r\n      [utils.asGridCoord(-1, 1)]: true,\r\n      [utils.asGridCoord(-1, 2)]: true,\r\n      [utils.asGridCoord(-1, 3)]: true,\r\n      [utils.asGridCoord(-1, 4)]: true,\r\n      [utils.asGridCoord(-1, 5)]: true,\r\n      [utils.asGridCoord(-1, 6)]: true,\r\n      [utils.asGridCoord(-1, 7)]: true,\r\n      [utils.asGridCoord(-1, 8)]: true,\r\n      [utils.asGridCoord(-1, 9)]: true,\r\n      [utils.asGridCoord(-1, 10)]: true,\r\n      [utils.asGridCoord(-1, 11)]: true,\r\n      [utils.asGridCoord(-1, 12)]: true,\r\n\r\n\r\n    },\r\n    cutsceneSpaces: {\r\n      [utils.asGridCoord(0,0)] : [\r\n        {\r\n          events: [\r\n            {type: \"changeMap\", map: \"Shop\"},\r\n          ]\r\n        }\r\n      ],\r\n    }\r\n  },\r\n}\r\nfunction generateRandomBehaviorLoop(steps) {\r\n  const directions = [\"up\", \"down\", \"left\", \"right\"];\r\n  let loop = [];\r\n\r\n  for (let i = 0; i < steps; i++) {\r\n    let randomDirection = directions[Math.floor(Math.random() * directions.length)];\r\n    loop.push({ type: \"walk\", direction: randomDirection });\r\n    loop.push({ type: \"walk\", direction: randomDirection });\r\n    loop.push({ type: \"walk\", direction: randomDirection });\r\n  }\r\n\r\n  return loop;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/OverworldMap.js b/OverworldMap.js
--- a/OverworldMap.js	(revision f3ff71803ed093ff0208c530cfb366a98eeabc3d)
+++ b/OverworldMap.js	(date 1739226500008)
@@ -216,37 +216,37 @@
         y: utils.withGrid(3),
         src: "./sprites/playerGun.png",
       }),
-      cheese: new Person({
+      cheese: new Cheese({
           x: utils.withGrid(2),
           y: utils.withGrid(9),
           src: "./sprites/cheese.png",
         behaviorLoop: generateRandomBehaviorLoop(20),
       }),
-      cheese1: new Person({
+      cheese1: new Cheese({
         x: utils.withGrid(10),
         y: utils.withGrid(6),
         src: "./sprites/cheese.png",
         behaviorLoop: generateRandomBehaviorLoop(20),
       }),
-      cheese2: new Person({
+      cheese2: new Cheese({
         x: utils.withGrid(6),
         y: utils.withGrid(10),
         src: "./sprites/cheese.png",
         behaviorLoop: generateRandomBehaviorLoop(20),
       }),
-      cheese3: new Person({
+      cheese3: new Cheese({
         x: utils.withGrid(9),
         y: utils.withGrid(5),
         src: "./sprites/cheese.png",
         behaviorLoop: generateRandomBehaviorLoop(20),
       }),
-      cheese4: new Person({
+      cheese4: new Cheese({
         x: utils.withGrid(1),
         y: utils.withGrid(10),
         src: "./sprites/cheese.png",
         behaviorLoop: generateRandomBehaviorLoop(20),
       }),
-      cheese5: new Person({
+      cheese5: new Cheese({
         x: utils.withGrid(6),
         y: utils.withGrid(7),
         src: "./sprites/cheese.png",
@@ -338,4 +338,4 @@
   }
 
   return loop;
-}
\ No newline at end of file
+}
Index: GameObject.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class GameObject {\r\n  constructor(config) {\r\n    this.id = null;\r\n    this.isMounted = false;\r\n    this.x = config.x || 0;\r\n    this.y = config.y || 0;\r\n    this.direction = config.direction || \"down\";\r\n    this.sprite = new Sprite({\r\n      gameObject: this,\r\n      src: config.src || \"./sprites/player.png\",\r\n    });\r\n\r\n    this.behaviorLoop = config.behaviorLoop || [];\r\n    this.behaviorLoopIndex = 0;\r\n\r\n    this.talking = config.talking || [];\r\n  }\r\n\r\n  mount(map) {\r\n    this.isMounted = true;\r\n    map.addWall(this.x, this.y);\r\n\r\n    setTimeout(() => {\r\n        this.doBehaviorEvent(map).then(r => {});\r\n    }, 10)\r\n  }\r\n\r\n  update() {\r\n  }\r\n\r\n  async doBehaviorEvent(map) {\r\n\r\n    if(map.isCutScenePlaying || this.behaviorLoop.length === 0 || this.isStanding) {\r\n        return;\r\n    }\r\n    let eventConfig = this.behaviorLoop[this.behaviorLoopIndex];\r\n    eventConfig.who = this.id;\r\n\r\n    const eventHandler = new OverworldEvent({map, event: eventConfig});\r\n    await eventHandler.init();\r\n\r\n    this.behaviorLoopIndex += 1;\r\n    if(this.behaviorLoopIndex === this.behaviorLoop.length) {\r\n        this.behaviorLoopIndex = 0;\r\n    }\r\n\r\n    await this.doBehaviorEvent(map);\r\n  }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/GameObject.js b/GameObject.js
--- a/GameObject.js	(revision f3ff71803ed093ff0208c530cfb366a98eeabc3d)
+++ b/GameObject.js	(date 1739226500008)
@@ -5,6 +5,7 @@
     this.x = config.x || 0;
     this.y = config.y || 0;
     this.direction = config.direction || "down";
+    //this.angle = this.getAngle();  // Call getAngle method here to set angle
     this.sprite = new Sprite({
       gameObject: this,
       src: config.src || "./sprites/player.png",
@@ -16,12 +17,28 @@
     this.talking = config.talking || [];
   }
 
+  getAngle() {
+    const angleMap = {
+      "up": 90,
+      "down": 270,
+      "left": 180,
+      "right": 0,
+    };
+    return angleMap[this.direction] || 0;  // Use this.direction here to get the angle
+  }
+  getX() {
+    return this.x;
+  }
+  getY() {
+    return this.y;
+  }
+
   mount(map) {
     this.isMounted = true;
     map.addWall(this.x, this.y);
 
     setTimeout(() => {
-        this.doBehaviorEvent(map).then(r => {});
+      this.doBehaviorEvent(map).then(r => {});
     }, 10)
   }
 
@@ -29,9 +46,8 @@
   }
 
   async doBehaviorEvent(map) {
-
     if(map.isCutScenePlaying || this.behaviorLoop.length === 0 || this.isStanding) {
-        return;
+      return;
     }
     let eventConfig = this.behaviorLoop[this.behaviorLoopIndex];
     eventConfig.who = this.id;
@@ -41,10 +57,9 @@
 
     this.behaviorLoopIndex += 1;
     if(this.behaviorLoopIndex === this.behaviorLoop.length) {
-        this.behaviorLoopIndex = 0;
+      this.behaviorLoopIndex = 0;
     }
 
     await this.doBehaviorEvent(map);
   }
-
-}
\ No newline at end of file
+}
Index: Person.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class Person extends GameObject {\r\n  constructor(config) {\r\n    super(config);\r\n    this.movingProgressRemaining = 0;\r\n    this.isStanding = false; \r\n\r\n    this.isPlayerControlled = config.isPlayerControlled || false;\r\n\r\n    this.directionUpdate = {\r\n      \"up\": [\"y\", -1],\r\n      \"down\": [\"y\", 1],\r\n      \"left\": [\"x\", -1],\r\n      \"right\": [\"x\", 1],\r\n    }\r\n  }\r\n\r\n  update(state) {\r\n    if (this.movingProgressRemaining > 0) {\r\n      this.updatePosition();\r\n    } else {\r\n      if (!state.map.isCutScenePlaying && this.isPlayerControlled && state.arrow) {\r\n        this.startBehavior(state, {\r\n          type: \"walk\",\r\n          direction: state.arrow\r\n        })\r\n      }\r\n    this.updateSprite(state);\r\n    }\r\n  }\r\n\r\n  startBehavior(state, behavior) {\r\n    this.direction = behavior.direction;\r\n\r\n    if(behavior.type === \"walk\") {\r\n    console.log(state.map.isSpaceTaken(this.x, this.y, this.direction));\r\n    if(state.map.isSpaceTaken(this.x, this.y, this.direction)) {\r\n      behavior.retry && setTimeout(() => {\r\n          this.startBehavior(state, behavior)\r\n      },10)\r\n      return;\r\n    }\r\n    state.map.moveWall(this.x, this.y, this.direction);\r\n    this.movingProgressRemaining = 16;\r\n      this.updateSprite(state);\r\n    }\r\n\r\n    if (behavior.type === \"stand\") {\r\n      this.isStanding = true;\r\n      setTimeout(() => {\r\n        utils.emitEvent(\"PersonStandComplete\", {\r\n          whoId: this.id\r\n        })\r\n        this.isStanding = false;\r\n      }, behavior.time)\r\n    }\r\n\r\n  }\r\n\r\n  updatePosition() {\r\n      const [property, change] = this.directionUpdate[this.direction];\r\n      this[property] += change;\r\n      this.movingProgressRemaining -= 1;\r\n\r\n      if (this.movingProgressRemaining === 0) {\r\n        utils.emitEvent(\"PersonWalkingComplete\", {\r\n            whoId: this.id\r\n        })\r\n      }\r\n    \r\n  }\r\n\r\n  updateSprite() {\r\n    if (this.movingProgressRemaining > 0) {\r\n      this.sprite.setAnimation(\"walk-\"+this.direction);\r\n      return;\r\n    }\r\n    this.sprite.setAnimation(\"idle-\"+this.direction);\r\n  }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Person.js b/Person.js
--- a/Person.js	(revision f3ff71803ed093ff0208c530cfb366a98eeabc3d)
+++ b/Person.js	(date 1739226500008)
@@ -2,17 +2,47 @@
   constructor(config) {
     super(config);
     this.movingProgressRemaining = 0;
-    this.isStanding = false; 
-
+    this.isStanding = false;
     this.isPlayerControlled = config.isPlayerControlled || false;
+    this.canShoot = this.isPlayerControlled;  // Only player-controlled characters can shoot
+
+    // Bind shoot method to the current instance
+    this.shoot = this.shoot.bind(this);
 
     this.directionUpdate = {
       "up": ["y", -1],
       "down": ["y", 1],
       "left": ["x", -1],
       "right": ["x", 1],
+    };
+
+    // Add KeyPressListener for Shift key
+    if (this.isPlayerControlled) {
+      new KeyPressListener("Shift", () => {
+        this.shoot();
+      });
     }
   }
+
+  // Define the shoot method
+  shoot() {
+    if (!this.canShoot) {
+      console.log("This character cannot shoot.");
+      return;  // Don't shoot if the character is not allowed to shoot
+    }
+
+    const dirX = Math.cos(this.getAngle());
+    const dirY = Math.sin(this.getAngle());
+    const x = this.getX();
+    const y = this.getY();
+
+    const radius = 32 * 0.5; // Bullet radius offset
+    const bx = x + dirX * radius; // Bullet's starting X position
+    const by = y + dirY * radius; // Bullet's starting Y position
+
+    // Create a new Bullet and pass in the canvas context
+    new Bullet({}, bx, by); // No need to pass context if it's handled by Bullet itself
+  }
 
   update(state) {
     if (this.movingProgressRemaining > 0) {
@@ -30,17 +60,17 @@
 
   startBehavior(state, behavior) {
     this.direction = behavior.direction;
+    this.angle = this.getAngle(); // Update the angle based on the new direction
 
     if(behavior.type === "walk") {
-    console.log(state.map.isSpaceTaken(this.x, this.y, this.direction));
-    if(state.map.isSpaceTaken(this.x, this.y, this.direction)) {
-      behavior.retry && setTimeout(() => {
+      if(state.map.isSpaceTaken(this.x, this.y, this.direction)) {
+        behavior.retry && setTimeout(() => {
           this.startBehavior(state, behavior)
-      },10)
-      return;
-    }
-    state.map.moveWall(this.x, this.y, this.direction);
-    this.movingProgressRemaining = 16;
+        },10)
+        return;
+      }
+      state.map.moveWall(this.x, this.y, this.direction);
+      this.movingProgressRemaining = 16;
       this.updateSprite(state);
     }
 
@@ -53,12 +83,13 @@
         this.isStanding = false;
       }, behavior.time)
     }
-
   }
+
 
   updatePosition() {
       const [property, change] = this.directionUpdate[this.direction];
       this[property] += change;
+
       this.movingProgressRemaining -= 1;
 
       if (this.movingProgressRemaining === 0) {
Index: index.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>Dough or Die</title>\r\n        <link href=\"/styles.css\" type=\"text/css\" rel=\"stylesheet\">\r\n        <link href=\"/TextMessage.css\" type=\"text/css\" rel=\"stylesheet\">\r\n\r\n    </head>\r\n    <body>\r\n        <div class=\"game-container\">\r\n            <canvas class=\"game-canvas\" width=\"352\" height=\"198\"></canvas>\r\n        </div>\r\n\r\n        <!-- Scripts -->\r\n        <script src=\"/utils.js\"></script>\r\n        <script src=\"/DirectionInput.js\"></script>\r\n        <script src=\"/Overworld.js\"></script>\r\n        <script src=\"/GameObject.js\"></script>\r\n        <script src=\"/Person.js\"></script>\r\n        <script src=\"/Sprite.js\"></script>\r\n        <script src=\"/OverworldMap.js\"></script>\r\n        <script src=\"/OverworldEvent.js\"></script>\r\n        <script src=\"/TextMessage.js\"></script>\r\n        <script src=\"/KeyPressListener.js\"></script>\r\n        <script src=\"/init.js\"></script>\r\n\r\n    </body>\r\n</html>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/index.html b/index.html
--- a/index.html	(revision f3ff71803ed093ff0208c530cfb366a98eeabc3d)
+++ b/index.html	(date 1739226800207)
@@ -2,27 +2,28 @@
 <html>
     <head>
         <title>Dough or Die</title>
-        <link href="/styles.css" type="text/css" rel="stylesheet">
-        <link href="/TextMessage.css" type="text/css" rel="stylesheet">
+        <link href="./styles.css" type="text/css" rel="stylesheet">
+        <link href="./TextMessage.css" type="text/css" rel="stylesheet">
 
     </head>
     <body>
         <div class="game-container">
-            <canvas class="game-canvas" width="352" height="198"></canvas>
+            <canvas class="game-canvas" width="194" height="180"></canvas>
         </div>
 
         <!-- Scripts -->
-        <script src="/utils.js"></script>
-        <script src="/DirectionInput.js"></script>
-        <script src="/Overworld.js"></script>
-        <script src="/GameObject.js"></script>
-        <script src="/Person.js"></script>
-        <script src="/Sprite.js"></script>
-        <script src="/OverworldMap.js"></script>
-        <script src="/OverworldEvent.js"></script>
-        <script src="/TextMessage.js"></script>
-        <script src="/KeyPressListener.js"></script>
-        <script src="/init.js"></script>
+        <script src="./utils.js"></script>
+        <script src="./DirectionInput.js"></script>
+        <script src="./Overworld.js"></script>
+        <script src="./GameObject.js"></script>
+        <script src="./Person.js"></script>
+        <script src="./Cheese.js"></script>
+        <script src="./Sprite.js"></script>
+        <script src="./OverworldMap.js"></script>
+        <script src="./OverworldEvent.js"></script>
+        <script src="./TextMessage.js"></script>
+        <script src="./KeyPressListener.js"></script>
+        <script src="./init.js"></script>
 
     </body>
 </html>
\ No newline at end of file
Index: OverworldEvent.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class OverworldEvent {\r\n    constructor({map,event}) {\r\n        this.map = map;\r\n        this.event = event;\r\n    }\r\n\r\n    stand(resolve) {\r\n        const who = this.map.gameObjects[ this.event.who ];\r\n        who.startBehavior({\r\n            map: this.map\r\n        }, {\r\n            type: \"stand\",\r\n            direction: this.event.direction,\r\n            time: this.event.time\r\n        })\r\n\r\n        //Set up a handler to complete when correct person is done walking, then resolve the event\r\n        const completeHandler = e => {\r\n            if (e.detail.whoId === this.event.who) {\r\n                document.removeEventListener(\"PersonStandComplete\", completeHandler);\r\n                resolve();\r\n            }\r\n        }\r\n        document.addEventListener(\"PersonStandComplete\", completeHandler)\r\n\r\n    }\r\n\r\n    walk(resolve) {\r\n        const who = this.map.gameObjects[this.event.who];\r\n        who.startBehavior({\r\n            map: this.map\r\n        },{\r\n            type: \"walk\",\r\n            direction: this.event.direction,\r\n            retry: true\r\n        })\r\n        const completeHandler = e => {\r\n            if(e.detail.whoId === this.event.who) {\r\n                document.removeEventListener(\"PersonWalkingComplete\", completeHandler);\r\n                resolve();\r\n            }\r\n        }\r\n        document.addEventListener(\"PersonWalkingComplete\", completeHandler)\r\n    }\r\n\r\n    textMessage(resolve) {\r\n\r\n        if(this.event.faceHero) {\r\n            const obj = this.map.gameObjects[this.event.faceHero];\r\n            obj.direction = utils.oppositeDirection(this.map.gameObjects[\"hero\"].direction);\r\n        }\r\n        const message = new TextMessage({\r\n            text: this.event.text,\r\n            onComplete: () => resolve()\r\n        })\r\n        message.init(document.querySelector(\".game-container\"))\r\n    }\r\n\r\n    changeMap(resolve) {\r\n        this.map.overworld.startMap( window.OverworldMaps[this.event.map] );\r\n        if (this.event.map === \"Outside\") {\r\n            document.body.style.cursor = 'url(\"./sprites/crosshair.png\"), auto';\r\n        } else {\r\n            document.body.style.cursor = \"auto\";\r\n        }\r\n        resolve();\r\n    }\r\n\r\n    init() {\r\n        return new Promise(resolve => {\r\n            this[this.event.type](resolve)\r\n        })\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/OverworldEvent.js b/OverworldEvent.js
--- a/OverworldEvent.js	(revision f3ff71803ed093ff0208c530cfb366a98eeabc3d)
+++ b/OverworldEvent.js	(date 1739226500008)
@@ -66,6 +66,7 @@
         resolve();
     }
 
+
     init() {
         return new Promise(resolve => {
             this[this.event.type](resolve)
Index: door.js
===================================================================
diff --git a/door.js b/door.js
deleted file mode 100644
--- a/door.js	(revision f3ff71803ed093ff0208c530cfb366a98eeabc3d)
+++ /dev/null	(revision f3ff71803ed093ff0208c530cfb366a98eeabc3d)
@@ -1,6 +0,0 @@
-class Door { //if player touches the box (goes through the door) the level will switch to the shooter 
-    constructor(game,x,y) {
-        Object.assign(this, {game, x, y});
-        this.BB = new BoundingBox(8,34,12,10);
-    }
-}
\ No newline at end of file
Index: Sprite.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class Sprite {\r\n  constructor(config) {\r\n\r\n    //Set up the image\r\n    this.image = new Image();\r\n    this.image.src = config.src;\r\n    this.image.onload = () => {\r\n      this.isLoaded = true;\r\n    }\r\n\r\n    //Shadow\r\n    this.shadow = new Image();\r\n    this.useShadow = true; //config.useShadow || false\r\n    if (this.useShadow) {\r\n      this.shadow.src = \"./sprites/shadow.png\";\r\n    }\r\n    this.shadow.onload = () => {\r\n      this.isShadowLoaded = true;\r\n    }\r\n\r\n    //Configure Animation & Initial State\r\n    this.animations = config.animations || {\r\n      \"idle-down\" : [ [0,0] ],\r\n      \"idle-right\": [ [0,1] ],\r\n      \"idle-up\"   : [ [0,2] ],\r\n      \"idle-left\" : [ [0,3] ],\r\n      \"walk-down\" : [ [1,0],[0,0],[3,0],[0,0], ],\r\n      \"walk-right\": [ [1,1],[0,1],[3,1],[0,1], ],\r\n      \"walk-up\"   : [ [1,2],[0,2],[3,2],[0,2], ],\r\n      \"walk-left\" : [ [1,3],[0,3],[3,3],[0,3], ]\r\n    }\r\n    this.currentAnimation = \"idle-right\"; // config.currentAnimation || \"idle-down\";\r\n    this.currentAnimationFrame = 0;\r\n\r\n    this.animationFrameLimit = config.animationFrameLimit || 8;\r\n    this.animationFrameProgress = this.animationFrameLimit;\r\n\r\n\r\n    //Reference the game object\r\n    this.gameObject = config.gameObject;\r\n  }\r\n\r\n  get frame() {\r\n    return this.animations[this.currentAnimation][this.currentAnimationFrame]\r\n  }\r\n\r\n  setAnimation(key) {\r\n    if (this.currentAnimation !== key) {\r\n      this.currentAnimation = key;\r\n      this.currentAnimationFrame = 0;\r\n      this.animationFrameProgress = this.animationFrameLimit;\r\n    }\r\n  }\r\n\r\n  updateAnimationProgress() {\r\n    //Downtick frame progress\r\n    if (this.animationFrameProgress > 0) {\r\n      this.animationFrameProgress -= 1;\r\n      return;\r\n    }\r\n\r\n    //Reset the counter\r\n    this.animationFrameProgress = this.animationFrameLimit;\r\n    this.currentAnimationFrame += 1;\r\n\r\n    if (this.frame === undefined) {\r\n      this.currentAnimationFrame = 0\r\n    }\r\n\r\n\r\n  }\r\n\r\n\r\n  draw(ctx) { //REMEMBER TO ADD CAMERA BACK\r\n    const x = this.gameObject.x - 8; // + utils.withGrid(5) - camera.x\r\n    const y = this.gameObject.y - 18; //+ utils.withGrid(5) - camera.y\r\n\r\n    this.isShadowLoaded && ctx.drawImage(this.shadow, x, y);\r\n\r\n\r\n    const [frameX, frameY] = this.frame;\r\n\r\n    this.isLoaded && ctx.drawImage(this.image,\r\n      frameX * 32, frameY * 32,\r\n      32,32,\r\n      x,y,\r\n      32,32\r\n    )\r\n\r\n    this.updateAnimationProgress();\r\n  }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Sprite.js b/Sprite.js
--- a/Sprite.js	(revision f3ff71803ed093ff0208c530cfb366a98eeabc3d)
+++ b/Sprite.js	(date 1739226500008)
@@ -90,4 +90,5 @@
     this.updateAnimationProgress();
   }
 
+
 }
\ No newline at end of file
